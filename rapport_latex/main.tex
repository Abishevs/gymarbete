\documentclass[swedish,a4paper]{article}
\usepackage[swedish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{changepage}
\usepackage{algorithm}	   % CODEFormating
\usepackage{algpseudocode} % CODEFormating
\usepackage{csquotes}      % Recommended
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{caption}
\graphicspath{ {images/} }
\usepackage[titletoc]{appendix}
\usepackage{listings, listings-rust}
\usepackage{longtable}
\usepackage{tikz}
\usepackage{tikz-cd}
\usepackage[nopostdot,nonumberlist]{glossaries}
\usepackage{pgfplots}
\usepackage{color}
\usepackage[margin=2cm]{geometry}
\usepackage{subcaption}
\usepackage[style=authoryear,
	    sorting=nty,
 	    backend=biber, 
            natbib=true]{biblatex}

\usepackage{hyperref}
\usepackage[swedish]{cleveref}
\usepackage{adjustbox}
\usepackage{float}
% \overfullrule=5pt % for diognosing overflow, draws an black line 

\makeglossaries
\glstoctrue
\input{ordlista}

\pgfplotsset{compat=1.14}
\lstset{ % General settings for listings
	basicstyle=\ttfamily\small, 
	commentstyle=\color{green},
	keywordstyle=\color{blue},
	stringstyle=\color{red},
	tabsize=4,
	% numbers=left,
	% stepnumber=1,
	% numbersep=-10pt,
	% numberstyle=\small\color{gray},
	showstringspaces=false,
	breaklines=true,
	showspaces=false,
}

% Redefine the listing name after loading cleveref
\renewcommand{\lstlistingname}{Kodlistning}
\crefname{lstinputlisting}{kodlistning}{kodlistningar} % For cleveref, singular and plural
\Crefname{lstinputlisting}{Kodlistning}{Kodlistningar} % For cleveref, singular and plural, capitalized

\renewcommand{\algorithmicrequire}{\textbf{Indata:}}
\renewcommand{\algorithmicensure}{\textbf{Utdata:}}
\renewcommand{\listalgorithmname}{Algoritmlista} % Ändrar "List of Algorithms" titel
\floatname{algorithm}{Algoritm} % Ändrar "Algorithm" till "Algoritm" i rubrike

\addbibresource{references.bib}
\renewcommand{\appendixpagename}{Bilagor}
\renewcommand*{\bibfont}{\small} % Adjust font size
\setlength{\bibitemsep}{1.5em} % Increase space between entries
\setlength{\bibhang}{2em} % Indent bibliography entries

\renewcommand*\contentsname{Innehåll}

\input{commands} % Custom commands

\begin{document}

\input{titlepage}

\begin{center}
    \large
    \textbf{Abstract}
\end{center}
\vspace{0.5cm} 
\begin{adjustwidth}{2cm}{2cm} 
This study presents a comprehensive analysis of three card shuffling algorithms:
Riffle Shuffle, Pile Shuffle (in three variations) and Wheel Fisher-Yates
Shuffle. The objective is to assess their statistical randomness, efficiency,
and practical applicability in the design of a potential card shuffler machine.
Large-scale simulations were performed to generate extensive shuffling datasets,
with the classical poker test and STDMean test applied to assess their
randomness. The practical feasibility was theorized, supported by conceptual
diagrams. The results did not favor a singular method as superior in all
aspects. Instead, the Pile Shuffle with 10 bins and 4 iterations emerged as the
most balanced choice, offering optimal randomness and practicality for
construction. While the Wheel Fisher-Yates Shuffle presents a more complex
design, it uniquely facilitates the shuffling of multiple decks in a single
iteration. The Riffle Shuffle, while traditional, requires further investigation
to optimize its implementation.
\vspace{1cm} 
\begin{center}
    \large
    \textbf{Acknowledgments}
\end{center}
\vspace{0.5cm} 
% We will thank our moms for raising such an arrogant, one sided dorks.
Special thanks to our mentor, Elias Lindqvist, for his invaluable guidance and
dedication to our development as writers. His expertise, passion for grammar,
and rigorous approach to research and citation have profoundly impacted us,
pushing our boundaries to new heights and instilling a meticulous and analytical
mindset. His countless hours of feedback and support have been crucial to our
growth and the success of this project.
\newpage

\end{adjustwidth}


\tableofcontents
\newpage

\glsaddall[] % adds all ordlist.tex entries
\printglossary[title=Ordlista] % Ordlista printas här
\newpage

\section{Inledning}
\subsection{Introduktion till ämnet}
Spelbranschen är en industri som omsätter miljardbelopp och precis som alla
industrier utvecklas den med resten av världen. Industrier över hela världen har
som mål att hitta nya sätt att effektivisera och sänka kostnad på det arbete som
utförs för att bedriva vinst, och spelbranschen har följt denna långvariga trend
med till exempel online kasinon. Inom spelbranschen är kortspel vanligt
förekommande, att försöka automatisera dem är därför ett logiskt steg att ta, men för
en stor industri vill man vara extra säker på att allt utförs på bästa sätt.
Alla sätt att blanda kort är nämligen inte lika bra, vilken sorteringsmetod som
används kan ha påverkan på resultatet. Teknologins inflytande inom spelbranschen har
ökar kraftigt med digitaliseringen, de största delarna av branschen bedrivs mer och mer av maskiner
och algoritmer som får stor potentiellt inflytande på spelresultat, därför är
det bäst att börja tänka på möjliga problem så snart som möjligt. Redan nu finns
det blandningsmaskiner för kortlekar som vi inte vet någonting om; varken hur de
funkar eller hur bra de är. Allt som vi vet är de är certifierade av
tredjepartsföretag.

\subsection{Syfte}
\label{sec:purpose}
Syftet med denna undersökning är att ta fram den hypotetiskt bästa kortblandaren
utifrån två faktorer: 1) hur slumpmässigt den algoritm som den byggs efter kan
blanda kort; 2) till vilken grad den potentiella maskinen byggd efter algoritmen
skulle fungera i verkligheten. Med resultaten förväntas variationen i
slumpmässighet för olika blandningsmetoder kunna visas upp samt kunna använda de
resultaten för att komma fram till den hypotetiskt definitiva maskinen, något
som är viktigt då spelbranschen handlar mycket om chans. Det är därför viktigt
att se till att allt funkar på bästa sätt. I den här vetenskapliga rapporten
kommer en jämförelse av hur effektivt framtagna blandningsmetoder kan fungera i
en hypotetisk blandningsmaskin att utföras. Samtidigt som man kan utforska hur
en dator kan göra slumpmässiga sekvenser på ett effektivt sätt med tanken att
den ska tillämpas till en potentiell kortblandare. Detta är viktigt för att
spelbranschen är en stor industri som handlar mycket om tur, att se till att de
slumpmässiga resultaten är framtagna på bästa möjliga sätt är en essentiell del.
Vi söker med hjälp av data svaret på frågan:

Utifrån slumpmässighet och effektivitet, vilken kortblandningsmetod är bäst för
en potentiell spelkortsblandare som uppfyller följande:
\begin{itemize}
	\item Fysiskt tillämpning: Hur pass väl den kan framställas i verkligheten 
	\item Effektivitet: Utifrån mjukvaras och hårdvaras perspektiv
        \item Kortblandnings slumpmässighet
\end{itemize}


\section{Teori}
%\subsection{Beräkningsteori}
%
%Beräkningsteori är en del av matematik vars syfte är grundat i hur och om
%problem kan bli lösta på olika beräkningssätt. Beräkningsteori har flera olika
%grenar. En gren handlar om vad som går att bevisa inom matematik angående om
%nummer och funktioner är beräkneliga eller inte. Med beräknelig menas något som
%kan beräknas, det vill säga värderas, uppfattas eller förutses, när det kommer
%till matematik syftar det på att bestämma något via matematiska
%modeller eller processer, alltså att kalkylera.

\subsection{Slumpmässighet}
\label{sec:slump}
%todo: edit text below to fit more with the overal topic "randomness"
%and to fit more seamlessly together
Beräkningsteori är en del av matematik vars syfte är grundat i hur och om
problem kan bli lösta på olika beräkningssätt. Beräkningsteori har flera olika
grenar. En gren handlar om vad som går att bevisa inom matematik angående om
nummer och funktioner är beräkneliga eller inte. Med beräknelig menas något som
kan beräknas, det vill säga värderas, uppfattas eller förutses, när det kommer
till matematik syftar det på att bestämma något via matematiska
modeller eller processer, alltså att kalkylera.

Slumpmässighet är en egenskap som anger att något sker utan klart mönster. När
något är helt slumpmässigt är det i princip omöjligt att förutse. Slumpmässighet
inom matematik är byggd beräknings\-teori och den delas upp i två beroende på om
det gäller slumpmässighet av en bestämd mängd eller en oändlig mängd av objekt
\parencite[49-66]{Terwijn2016}.

\subsection{Slumptalsgeneratorer}
\label{sec:prng}

Som det nämndes i sektion \ref{sec:slump}  finns det olika typer av slump.
Följaktligen finns det olika typer av slumptalsgeneratorer. Dem kan indelas i två
typer icke-deterministiska och deterministiska så kallade \textit{äkta
slumptalsgeneratorer} (true random number generators - TRNG) respektive 
\textit{pseudo slumptalsgeneratorer} (psuedo random number
generators - PRNG). Icke-deterministiska processer använder sig av naturliga
fenomen e.g. termisk natur, kosmisk strålning eller radioaktivt sönderfall.
Därför behöver denna metod speciell utrustning. Deterministiska processer är när en slumptal algoritm simulerar en slumpmässigt
händelse. Men den behöver ett start data som sedan utför ett kedja av
operationer. Därför deterministiska behöver slumptalsgenerator ett frö (seed) att
utgå ifrån. På så sätt kan exakt samma sekvens av slumpmässiga sekvenser
återskapas om fröet
är känd \parencite{salinhanes2011}.

% \textbf{TRNG} är till när den absolut säkraste slumptal ska genereras
Det finns olika områden när TRNG eller PRNG är lämpligast att använda.
Enligt \textit{random.org} sammanfattar dem dessa till följande PRNG vid simulationer och
TRNG vid kasino spel \parencite{randomorg}. 


% Här berätta om ChaCha20 \parencite{chacha} den som är biobliotekes rand
% \parencite{rand_crate} default PRNG och mersenne twister som egentligen var första
% hands val
% \parencite{mersenne_twister} men som vi sedan bytte till ChaCha för att i rust
% är det relativt svårt att  implementera och använda mersenne twister. Berätta om
% dem skillnaderna som finns.
% \parencite{salinhanes2011}.
%
% En väldigt känd och testad algoritm är Mersenne Twister (MT 19937) som
% har en väldigt långt period innan siffrorna börjar att upprepa sig, mer
% exakt $2^{19937}$ \parencite{mersenne_twister}.
%
% lltså nämn att för att det här är som et proof of concept, borde vid
% senare tillfälle användas en hårdvara PRNG och icke software PRNG.
% Men på grund av detta undersökning handlar mesta dels om stora mängder av data
% simulationer så måste vi använda och "Sacrifice" verkliga till att lättare
% skapa simulationer!

\subsection{Bakgrund av blandingsmetoder}

\subsubsection{Riffle Shuffle}
\label{sec:riffle_shuffle}
Riffle Shuffle är den vanligaste kortblandningsmetoden. Riffle Shuffle är utförda genom att dela upp en kortlek i två delar och sedan interfoliera dem för att få ut en blandad kortlek.
Riffle Shuffle har undersökts över en lång tidsperiod. För matematiska syften angående Riffle Shuffle finns det en modell, Gilbert-Shannon-Reeds-modellen.  Gilbert-Shannon-Reeds-modellen är en matematisk modell vars resultat är lika dem från Riffle Shuffle utförd av en människa. Modellen utvecklades av Gilbert och Shannon \parencite{gilbertshuftheo}, och senare oberoende av Reeds 1981 i ett verk som inte publicerades \parencite[77-79]{gsr2003mathematical}.  Mycket tidigare forskning om Riffle Shuffles egenskaper bygger på Gilbert-Shannon-Reeds-modellen till exempel \textcite{dovetaillair}, en studie vars resultat verkar medföra att Riffle Shuffle borde göras sju gånger för att få en helt slumpmässig blandning. 
% Det finns många olika metoder att blanda kort med riffle shuffle.
% Gilbert-Shannon-Reeds-modellen är en matematisk modell på riffle shuffle som ger
% resultat nära dem en riffle shuffle utförd av en människa ger.

\begin{figure}[H]
	\begin{center}
		\includegraphics{images/rifflle-shuffle.pdf}
	\end{center}
	\captionsetup{justification=centering,margin=2cm}
	\caption{Steg i processen för Riffle Shuffle. Illustrationen visar de
	iterativa stegen från den ursprungliga högen (A), uppdelning i två
	högar (B), infoga dem två högarna med varandra för att bilda en ny hög.
        Pilar indikerar riktningen för blandningsprocessen.}
	\label{fig:riffle_shuffle_1}
\end{figure}

% \begin{algorithm}
% \caption{Riffle Shuffle Pseudokod}
% \begin{algorithmic}[1]
% \Require $Deck$
% \Ensure Blandad $Deck$
% \For {$card$ in len($Deck$)} { 
% \State $DeckHalf1.push(card) $ 
% \State $DeckHalf2 \gets $
% }
% \State Initialize an empty list $ShuffledDeck$
% \While{both $DeckHalf1$ and $DeckHalf2$ are not empty}
%     \State Generate a random number $RandId$ between 0 and 1
%     \If{$RandId \leq$ length of $DeckHalf1$ divided by total length of both halves}
%         \State Remove the top card from $DeckHalf1$ and add it to $ShuffledDeck$
%     \Else
%         \State Remove the top card from $DeckHalf2$ and add it to $ShuffledDeck$
%     \EndIf
% \EndWhile
% \State Copy $ShuffledDeck$ back to $Deck$
% \end{algorithmic}
% \end{algorithm}

\subsubsection{Pile Shuffle}
\label{sec:pile_shuffle}
Pile Shuffle är en kortblandningsmetod som genomförs med fysiska
kort. Processen utgår från att ett kort
från kortleken läggs i en av flera olika högar. Processen försätter
tills alla kort från kortleken har flyttats till en av högarna. Sedan
läggs  alla högar ihop i en ny kortlek. Flöde av en sådan metod visas i Figur
\ref{fig:pile_shuffle}.

Att hitta en kortleksblandare som hade implementerat en Pile Shuffle metoden var
inte enkelt uppdrag. Men det hittades en kortleksblandare som lyckades med det.
Källan hittades på YouTube  och var skapad av \textcite{3DprintedLife2021}.
Blandningsmaskinen kallas Shuffle-o-matic (SOC). I denna YouTube video visas
det upp hur en sådan maskin fungerar och hur kan denna 3D printas.  Där meddelas
det att kortmatningsmekanismen var svårt att implementera p.g.a. hur tunna
spelkort är.

\begin{figure}[H]
	\begin{center}
		\includegraphics{images/pile_shuffle.pdf}
	\end{center}
	\captionsetup{justification=centering,margin=4cm}
	\caption{Steg i processen för Pile Shuffle. Illustrationen visar de
	iterativa stegen från den ursprungliga högen (A), genom uppdelning i
	högar (B), temporära högar (C), omarrangering av temporära högar (D),
	och tillbaka till en enda hög (E). Pilar indikerar riktningen för
	blandningsprocessen.
	}
	\label{fig:pile_shuffle}
\end{figure}


\subsubsection{Inblick i en professionell kortleksblandare}
\label{sec:wheel}

\noindent
\begin{minipage}{0.5\textwidth}
Information om professionella kortleksblandare är 
begränsat, speciellt när det gäller vilka algoritmer som dessa
använder. Det 
har uppfattats att detta beror på säkerhetsskäl d.v.s. att den ska
inte vara tillgänglig till
allmänheten. På detta sätt säkerställer och
minimerar utvecklarna av dessa maskiner risken att
obehöriga parter hackar dem. 
Men under litteraturforskning fasen hittades en gammal YouTube-video som presenterar hur en professionell kortblandningsmaskin ser ut och
fungerar från insidan \parencite{shufflerVideo}. En bild av en likadan 
blandningsmaskin hittades, se Figur \ref{fig:casino_shuffler}. Ett 
tydligt mönster som båda maskinerna har är att utvecklarna valde att ha 
full kontroll av enskilda korts position när dem blandas. Det betyder att denna
blandningsmaskin skulle teoretiskt sätt kunna använda vilken
algoritm som helst, samt generera en riggad kortlek. Med riggad kortlek
menas att ordningen är definierad i förväg. Motiveringar till detta skulle
inkludera skäl av vinst men detta är
inte bevisat på ett eller ett annat sätt. 
\end{minipage}%
\hfill
\begin{minipage}{0.5\linewidth}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\linewidth]{automatic_card_shuffler.jpg}
    \captionsetup{width=0.5\linewidth}
    \caption{Inblick i en isärtagen kortleksblandare.}
    \label{fig:casino_shuffler}
\end{figure}
\end{minipage}

\subsection{Det klassiska pokertestet}
\label{sec:poker_test}


% Poker Test kan anpassas till vilken som helst sekvens av nummer 3-5 stora
% mängder. Men för att vår simulation använder vi samma nummer som pokerkort
% därför kan vi anpassa klassiska poker test var man använder alla möjliga
% pokerhänder av sekvens av 5 kort. Resultatet från karakterisering av händer
% använder man i en chi-square testet. För att göra testet rätt följde jag
% Engineering Statistics handbok (NIST 2012). Dvs för att avgöra hur många 
% händer
% uppkom med avseende till teoretiska värdena EXPECTED vs OBSERVED värdena. sen
% jämför man chi-square resultatet till en CRITICAL värde om den värden som vi
% fick är mindre kan vi med säkerhet säga att algoritmen är slumpmässigt och 
%* vice versa.

\noindent
\begin{minipage}[t]{0.6\textwidth}
Ett klassiskt pokertest används för att avgöra slump\-mässighet i numeriska 
sekvenser, oftast för att testa slumptalsgeneratorer. Testet utförs genom
att 3 till 5 nummer väljs ut ur en sekvens och placeras i en av sju
kategorier beroende på mönstret som talen har.  Mönstren är baserade på händer i poker vilket är varför testet kallas pokertest \parencite{Abdel2014}. 
De olika mönster som letas efter i talen visas i Tabell \ref{tab:num_poker_hands}.
\indent
 Antalet mönster i varje kategori räknas för att få en distribution, som
 då jämförs med en distribution som stämmer överens med sannolikheten
 att få de olika mönstren. Om det totala antalet mönster är $n$ och
 sannolikheten för en pokerhand $i$ är $p_i$, därför borde antalet mönster i
 den kategori vara 
\end{minipage}%
\hfill
\begin{minipage}[t]{0.40\textwidth}
% \begin{table}[H] 
	\centering
	\captionsetup{width=0.5\textwidth}
	\captionof{table}{Vanliga kategorier till pokertest}
    \label{tab:num_poker_hands}
	\begin{tabular}{|l|c|}
	\hline 
	Pokerhand & Mönster \\ \hline  
	Femtal & AAAAA \\ \hline
	Fyrtal & AAAAB \\ \hline
	Kåk & AAABB \\ \hline
	Tretal & AAABC \\ \hline
	Tvåpar & AABBC \\ \hline
	Par & AABCD \\ \hline
    	Inget mönster & ABCDE \\ \hline
	
\end{tabular}
%
% \end{table}
\end{minipage}
$$e_i = p_i * n$$
 Där $e_i$ är antalet mönster som
 borde matcha pokerhand $i$. För att bestämma om resultaten kan komma
 från en rättvis kortlek jämförs de resultat som fåtts av att plocka
 ut nummer mot de resultat som fås av sannolikheten via ett chi-två-test.

\subsubsection{Chi-två-test}
\label{sec:chi_square}
Inom statistik används ett \textit{goodness-of-fit} test för att mäta
hur pass väl fördelningen för den data som observerats stämmer överens
med fördelningen som data förväntas ha utifrån en model. Karl Pearsons
chi-två-test kan användas som \textit{goodness-of-fit} test. Det
använder chitvåfördeling. I testet jämförs ett värde $\chi^2$ med ett
kritiskt värde för att bestämma om den observerade följer den förväntade
fördelningen. $\chi^2$ beräknas enligt formeln
$$\chi^2 = \sum_{i=1}^k\frac{(O_i - E_i)^2}{E_i}$$
Där $O_i$ är observerade frekvensen för en kategori av data $i$ och $E_i$
är förväntade frekvensen för kategorin $i$.
Det kritiska värdet fås av antalet frihetsgrader(kategorier - parametrar)
och signifikansnivån som bestämts för testet. Såsom ett viktigt aspekt i chi-två-test är att data mängderna som testas inte kan vara för
små. Det rekommenderas att $O_i$ inte är mindre en 5 \parencite{nist}.

%Chi-square, chi-två testing eller som den också betecknas $\chi^2$ är statistikt test
%som oftas används till att definera och beräkna slumpmässighet av bestämd sannolikhet.
%$$ \chi^2 = \sum_{i=1}^k \frac{(O_i - E_i)^2}{E_i}$$
%Vart $O_i$ är observerade frekvensen för kategorin $i$ och $E_i$ är förväntade
%frekvensen för kategorin $i$ \parencite{nist}.
%\subsection{ testet}
%\label{sec:stdmean}
%Datamängden är utformat på sätt att kort värde är alltså dess position i
%kortleken. Första kort är 0 dvs position 0 i kortleken. Kalkylerar varje
%columns korts medelvärde och standaravvikelse ska man förustpå att medelvärde
%borde ligga nära $51/2= 25.5$ detta betyder att i position 0 har alla kort varit
%i, och om standaravviklse i figuren är höga torn har position 0 stort variation
%av vilka kort som var där. Detta är då en indikator på en uniform distribution
%som betyder en slumpmässigt algoritm.

%Förklara logiken till stanardavvikelse och medelvärdet
%i logiken med avgörande av normal distribitution och hur den ger ett mått/bild på randomness

\subsection{Programmeringsverktyg}
\label{sec:verktyg}
Inom ramen för denna studie är användningen av programmeringsverktyg som Python
och Rust av stor betydelse. Denna sektion inkluderar beskrivningar av alla
verktyg som ska användas. Tyngden betonas av den tidigare forsknings ytterst
utmärkta arbete inom dataanalys verktyg som publicerats till öppen källkod för alla att
använda. För att utan dessa verktyg skulle denna studie inte
vara möjlig att utföra. 

\textbf{Python} är ett objektorienterat, dynamiskt programmeringsspråk 
med fokus på läsbarhet och enkel syntax \parencite{python}. Python
har etablerat sig som ett fundamentalt språk inom datavetenskap p.g.a. sitt
stora ekosystem av kraftfulla \gls{bibliotek}. 

\textbf{NumPy} är utvecklat av Travis Oliphant och ett globalt team av
bidragsgivare och är standardbiblioteket för vektoriserad aritmetisk beräkning i
Python. Dess effektiva hanteringsmetoder på stora datamängder och matematiska
operationer gör det till förstahandsval för dataanalys vid vetenskaplig
forskning \parencite{numpy}.

\textbf{SciPy}, en stor samling av öppen källkod-programvara för matematik och
vetenskap. Det är resultatet av samarbete mellan hundratals forskare och bidrar
till att göra komplexa matematiska beräkningar tillgängliga och effektiva
\parencite{scipy}. E.g. funktioner för utförandet av chi-två-test.

\textbf{Numba} är ett kompilatorbibliotek som översätter Python-kod till snabb maskinkod som körs på egen tråd. Detta projekt, som drivs av Anaconda, Inc.,
möjliggör betydande hastighetsförbättringar för dataintensiva implementationer 
förutsatt att det används fundamentala datatyper och operationer \parencite{numba}.  

\textbf{Matplotlib}, skapat av John D. Hunter och nu underhållet av en stor
utvecklargemenskap, är det ledande biblioteket för datavisualisering i Python.
Det gör det möjligt att enkelt skapa en mängd olika grafik och plotter, vilket
är kritiskt för analys och presentation av data \textcite{matplotlib}.

\textbf{Rust} är ett kompilerat statisk programmeringsspråk som fokuserar på
minnessäkerhet, samt minneseffektivitet och parallellism. Rust är känt för

sina avancerade funktioner som ägarskapssystemet (ownership), vilket
hjälper till att förhindra minnesläckor och tillåter säker
minneshantering utan en skräpsamlare (garbage collector)
\parencite{rust}. 
P.g.a. dessa egenskaper har det ökats popularitet av användning av Rust i
inbyggda system som ett motkandidat till programmeringsspråk C, detta  undersöktes
 på djupet av \textcite{sharma2023rust}.

\textbf{Rand} \gls{crate} är för pseudoslumptal generering med enkel användning
via \textit{Rng} trait. Samt säker och snabb behandling av fröet med
\textit{thread\_rng}, den använder algoritm ChaCha20 \parencite{rand_crate}.

\textbf{Rayon} \gls{crate}  är för att konvertera sekventiella 
iterationer i Rust till parallellt och säker exekvering 
\parencite{rayon_crate}.

Genom att använda dessa verktyg har denna studie kunnat utföra omfattande
simuleringar och dataanalyser på ett effektivt sätt. Deras tillgänglighet och
prestanda har varit avgörande för studiens framgång.

% grund av dens rika utbud av bibliotek, speciellt inom
% veten\-skaplig data\-behandling och data\-analys. Därför valdes det
% att utföra statistika tester som Poker test och \gls{stdmean} testet i Python.
% En till perspektiv till varför Python valdes är att analys och avgörande
% av slump\-mässighet är fundementalt komplex process icke räknebart, men det som
% underlättar framtagande av resulat är visuella grafer och tabeller. I

% Med detta sagt Pythons Matplotlib bibliotek underlättar processen av
% graf ritanade tillsammans i en symbious relation med NumPy som har styrka i
% datamängd represention och vektoriserad data\-bearbetning. Utfördes det
% mindre matematisk komplicerade tester med fokus på storleken av
% datamägderna som ger en god överblick av slumpmässighet av dem olika
% blandnings algoritmerna som simulerades. På avseende på ett teoretiskt
% perfekt blandnings resulat för samtliga metoder.


\section{Metod} 
Metoden för denna studie kan indelas i tre huvudområden:
(i) Framtagande av  blandningsalgoritmerna;
(ii) Simulering av kortblandningsprocesser;
(iii) Statistisk analys av insamlad data.

Inledningsvis kommer framtagande av blandningsalgoritmerna fokusera på
utvecklingen av specifika kortblandningsmetoder. Detta inkluderar både
etablerade metoder som Riffle Shuffle (\ref{sec:riffle_shuffle}), samt nyare,
innovativa tillvägagångssätt som Pile Shuffle (\ref{sec:pile_shuffle}). Såsom
anpassning av design av en professionell kortleksblandare (\ref{sec:wheel}).
Vilka valts ut baserat på deras potential i en potentiell kortleksblandare.
Dessa algoritmer är kritiska för bedömningen av kortblandningsmetodens
slumpmässighet och effektivitet, vilket är kärnan i studiens frågeställning. 
% Samt att besvara
% frågan om dess algoritmernas fysiskt tillämpning i en potentiell
% kortleksblandare.

Målsättningen är att djupgående undersöka kortblandningsmetodernas
fysiskt tillämplighet, dess effektivitet och slumpmässighet. Att utföra 
simulationer valdes eftersom att blandningsalgoritmerna
(processmässigt) skulle vara snarlika till dess potentiella kortleks\-blandare.
Därmed skulle det genereras mer tillförlitliga testresultat. Det är därför simulationsdelen
innefattar en kvantitativ metodik för att reducera den inneboende
slumpvariationen i de simulerade blandningsalgoritmerna. Det åstadkoms genom att generera en bestämd
mängd av kortleksblandningar, där datamängderna uppfyller kravet ifrån statistiska metoder. Dessa
statistiska  analysmetoder omfattar det klassiska pokertestet (\ref{sec:poker_test}), med
resultat given av chi-två-testet (\ref{sec:chi_square}). Det ingår även standardavvikelse- och medelvärdestest (\gls{stdmean}), vilket ger ett närmare inblick i korts variation i specifika
positioner i kortleken. Tillsammans dessa tester ger en tillfredsställande indikation på
blandningsmetodens slumpmässighet. 

Genom att välja denna metodik syftar studien till att utföra en omfattande
kvantitativ analys som inte enbart bedömer algoritmernas teoretiska
effektivitet men även dess praktiska tillämplighet i en potentiell kortleks\-blandare.
Detta tillvägagångssätt möjliggör en detaljerad utvärdering av varje algoritm,
dess implementering och slutliga prestanda, vilket är avgörande för att uppnå
studiens mål. Mer detaljerad beskrivning av specifika algoritmerna,
simuleringar av kortblandningar och statistiska utvärderingar presenteras i kommande 
underrubriker. 

För intresserade parter finns det källkod för algoritmernas implementation,
programmet som användes för simulation, samt implementationen av analysmetoderna
på Github se Bilaga \ref{app:github}.

% Valet av metodik syftar till att implementera blandsnigsalgoritmerna med syfte
% att motivera design valet och framställa dem med tanken att dessa skulle
% implementeras i ett potentiell kortleksblandare. Sedan  genomföra en 
% kvantitativ analys med användning av 
% simuleringar och statiska utvärderingar. Simulationen  Datamängden kakylerades med avseende på krav i det klassika
% pokertestet. Dessa metoder är detaljerat beskrivna i respektive underrubrik.
% under sin livscykel.
%
% Simulationen omfatar ett  för att minimera
% naturligt slumpmässighet i statiska metoder som ska tillämpas. Dessa 
% metoder är Klassikt poker test
% med resultat given av chi-två-fördelning respektive \gls{stdmean} testet.
% ett närmare undersökningen av 
% korts variationen  i alla positioner i kortleken med statiska metoder som standardavvikelsen,
% respektive medelvärdena av korts position.
%
% Detta metod valdes för att utföra ett kvantitiv undersökning med
% hjälp av simulation och statistiska tester.  
% dvs på liknande sätt hur ett fysiskt kortleks\-blandare skulle används under dens livscykel. 


\subsection{Testmiljö} 
I valet av testmiljö prioriterades operativsystemets kompatibilitet med
de utvecklingsverktyg som användes. Linux som operativsystem valdes på grund av dess
robusta stöd för programmeringsmiljöer och breda stöd för
mjukvaruutvecklingsverktyg. Dessutom erbjuder operativsystem Linux bättre kontroll
över systems\-resurser, vilket är avgörande för att uppnå följdriktiga
och till\-för\-litliga testresultat. Se Tabell \ref{tab:linux_env} för
 testmiljöns specifikationer.
\begin{table}[H]
\centering
\begin{tabular}{|l|p{5cm}|}  
\hline 
Typ & Specifikation  \\ \hline 
Processor & AMD Ryzen 5 3600 \newline 6 cores / 12 threads \newline 3.6 GHz \\ \hline
RAM & 15.93 GB \\ \hline
Hårddisk & KINGSTON SA400S3, 447 GB \\ \hline
Operativsystem & \texttt{Arch Linux x86\_64, \newline Linux kernel
6.6.9-arch1-1} \\ \hline
\end{tabular}
\captionsetup{width=0.5\textwidth}
\caption{Testmiljö med Linux som operativsystem.}
\label{tab:linux_env}
\end{table}

\subsection{Framtagande av blandningsalgoritmerna}
\label{sec:algos}
I detta avsnitt presenteras processen av framtagande och 
% kortblandningsalgoritmerna som utgör studies kärna. Här teoretiska grunden för
% Riffle Shuffe (\ref{sec:riffle_shuffle}), Pile Shuffle (\ref{sec:pile_shuffle})
% och design ifrån profesionell korleksblandare (\ref{sec:wheel}) kommer att
% anpassas till en potentiell kortleksblandare och implementeras för vidare undersökning. 
detaljerna kring varje algoritms kod och dess
möjliga implementering i en potentiell kortleksblandare.
% kommer att utforskas.
% vilket lägger grunden för en djupare analys av deras prestanda i efterföljande
% simulationer och analysmetoder.

Algoritmerna implementerades i programmeringsspråket Rust version 1.73.0. Rust
valdes p.g.a. dess höga abstraktioner med närmare tillgång till systemresurser
(för detaljer se avsnitt \ref{sec:verktyg}). Eftersom att i en fysisk maskin
skulle blandningsalgoritmen köras i ett inbyggd miljö det vill säga i ett system med
begränsade resurser. Därmed skapas på så sätt implicit en mer likvärdig miljö till en
potentiell kortblandningsmaskins miljö för efterföljande simulationer. 

Kompromissen som togs i implementation av algoritmerna är att
pseudoslumptalsgeneratorn (\gls{prng}) som används i denna studie kommer ifrån
Rand \gls{crate} som har inbyggt implementation av ChaCha20 (se sektion
\ref{sec:prng} för detaljer). Som tidigare nämnts behöver ChaCha20 mer
systemresurser och därför är inte tillgängligt i ett inbyggt system. Men
valet av att använda denna togs för att i simulerings miljö där \gls{prng} behövs
successivt i små tids intervaller kommer den att generera bättre pseudoslumptal
än en \gls{prng} som är anpassad till inbyggda system. Dessutom kommer den att
generera mer trovärdiga kortblandningar som är mindre influerade av dess
underliggande \gls{prng} implementation. 

\subsubsection{Anpassning av Riffle Shuffle}

 

% \noindent
Första blandningsmetoden som anpassades var den matematiska
Gilbert-Shannon–Reeds modell till en praktisk Rust kod (för djupgående bakgrund
om modellen se sektion \ref{sec:riffle_shuffle}). För enkelhetens skull ska denna metod
betecknas \gls{gsr} Riffle Shuffle eller enbart \gls{gsr}. Motiveringen av att
utforska denna var p.g.a. dess lockande egenskaper som hur den matematiska
modellen avspeglar människans kortblandningsprocess. Därför anpassades modellen för att
utforska om den kan vara ett lämpligt kandidat till den potentiella
kortleksblandaren.

Den matematiska formeln för \gls{gsr} distribution är anpassad på rad 6 se Algoritm
\ref{alg:gsr}. För att inte distrahera med tekniska utmaningar finns implementationen i
Rust i Bilaga \ref{app:gsr}.
\begin{algorithm}
\caption{GSR Riffle Shuffle pseudokod}
\label{alg:gsr}
\begin{algorithmic}[1]
\State $H1 \gets$ $OD$ \Comment{Alla kort från $OD$ (Original Deck) är placerade i $H1$}
\State $H2 \gets \frac{H1}{2}$ \Comment{$H2$ får hälften av kort (i sekvensiell
ordining)}
\State $HM \gets tom lista$ \Comment{Mittersa högen}
\While{$H1$ eller $H2$ inte är tomma}
\State $r \gets$ slumpmässigt tal mellan 0.0 och 1.0 \Comment{\gls{prng} för att
få ett slumpmässigt tal}
    \If{$r \leq (\text{längden av } H1) / (\text{längden av } H1 + \text{längden av } H2)$}
        \State flytta ett kort från $H1$ till $HM$
    \Else
        \State flytta ett kort från $H2$ till $HM$
    \EndIf
\EndWhile
\State flytta alla kort från $HM$ tillbaka till $H1$
\end{algorithmic}
\end{algorithm}
% I implementeringen av detta algoritm inför simuleringen gjordes det några
% optimeringar som 1)  
\begin{figure}[H]
	\centering
	\includegraphics[width=0.5\textwidth]{irl_riffle_shuffle.pdf}
	\captionsetup{width=0.5\textwidth}
	\caption{Ett illustrativt blandningsprocess
		diagram av
	Riffle Shuffle fundamentala mekaniska komponenter till den potentiella
	kortleksblandaren. Med 3 stycken högar $H1$, $HM$ respektive $H2$. Där sträckor representerar kort,
	cirkelformen representerar en roterande kortmatningsmekanism och mittersta
	högen är en höjbar mekanism i $y$-led.}
	\label{fig:irl_gsr}
\end{figure}

\boldsection{Potentiell fysisk implementation}: Anpassnings metodiken av
\gls{gsr} inledes med att det skissades upp en potentiell fysisk implementation av
Riffle Shuffle utifrån algoritmen, se Figur \ref{fig:irl_gsr}. Detta är ett
simplifierad version. För att t.ex. det borde finnas ett mekanism att flytta
kortet från $HM$ till $H1$ och $H2$. komplikationer med denna design kan inkludera
tidsplanerings problem d.v.s. att kortet från $H1$ träffar kortet från $H2$ på vägen
till $HM$.


% \clearpage % To not weirdly wrap other text

 % Först att testa hur väl den utför till att avspegla hur en människa blandar
 % kort och att det krävs exakt 7 iterationer för en kortlekblanding att vara
 % slumpmässigt 
 % för att utforska hur väl den presterar i
 % kortleksblandingar och om den skulle vara en lämligt kandidat för den
 % potentiella kortleksblandaren.

\subsubsection{Anpassning av Pile Shuffle}
Den andra blandningsmetoden som anpassades var Pile Shuffle.
För det första är den metoden designmässig 
annorlunda till Riffle Shuffle. Den har endast en roterande
kortmatningsmekansim samt enbart två stora delar, se Figur
\ref{fig:irl_pile}. Inspirationen för den potentiella designen 
kom ifrån
\textcite{3DprintedLife2021}. Abbreviation till denna  metod 
ska vara \gls{soc} Pile Shuffle eller enbart 
\gls{soc}. Denna metod har två varierande inställningar som 
inkluderar 1) antal fack $n$ och 2) maximalt antal kort per
fack $M$. I denna studie utforskades både \gls{soc} samt 
två till variationer av denna Six Pile Shuffle respektive 
Ten Pile Shuffle. Med följande inställningar:
\textbf{\gls{soc} Pile Shuffle} med $n = 8$ och $M = 10$. Sedan utforskades hur påverkas slumpmässighet med färre fack
därmed fysiska designen kan vara mindre. Detta blev till 
algoritmen som betecknas till 
\textbf{Six Pile Shuffle} med $n = 6$ och $M = 10$. Sist undersöktes om vad sker om inställningar blir till $n = 10$ och $M = 10$ denna algoritm kallas till
\textbf{Ten Pile Shuffle}.

\begin{algorithm}
\caption{Pile Shuffle pseudokod}
\label{alg:pile}
\begin{algorithmic}[1]
\Require En kortlek $H1$
\Ensure Blandad kortlek $H1$ 
\State $n \gets num$ \Comment{Antal fack}
\State $M \gets num $ \Comment{Max antal kort per facket}
\State $H2 \gets$ lista av $n$ tomma listor % \Comment{Bins för korten}
\For{$kort$ i $H1$}
    \Loop
        \State $sf \gets$ slumpmässigt fack index mellan $0$ och ($n-1$) \Comment{slumpmässigt fack (sf)}
        \If{$\text{längden av } H2[sf] < M$}
            \State Lägg $kort$ i $H2[sf]$
            \State \textbf{break}
        \EndIf
    \EndLoop
\EndFor
\State $H1 \gets$ sammanfoga alla facken i $H2$ \Comment{Samla ihop alla fack till en kortlek}
\end{algorithmic}
\end{algorithm}

% \begin{wrapfigure}{r}{0.6\textwidth}
\begin{figure}[H]
	\centering
	\includegraphics[width=0.4\linewidth]{irl_pile_shuffle.pdf}
	\captionsetup{width=0.5\textwidth} \caption{Ett illustrativt diagram av
		kortblandningsprocessen med 
	Pile Shuffle metoden. Fundamentala mekaniska komponenter till den potentiella
	kortleksblandaren, där sträckor är kort, cirkelformen är roterande
kortmatningsmekanismen. Med två högar, $H1$ och $H2$. Där $H1$ har plats för en
kortlek medans $H2$ har $n$ antal fack med maximalt $M$ antal kort per fack.}
	\label{fig:irl_pile}
	
\end{figure}
% \end{wrapfigure}

\subsubsection{Anpassning av design av professionell kortleksblandare}
Tredje blandningsmetoden som skapades var inspirerad av en professionell
kortleksblandare. P.g.a. denna design har den fack för varje kort därmed anpassades det
Fisher-Yates Shuffle.
% (för detaljerna se sektion \ref{sec:fisher_yates}).
D.v.s. först blandades en lista med index med
Fisher-Yates algoritmen och sedan flyttades kortet från $H1$ till $H2$ baserat på
slumpmässigt index se Figur \ref{fig:irl_wheel}. Denna metod skulle teoretiskt sätt kräva endast en iteration för att blanda en kortlek.

\begin{algorithm}
\caption{Wheel Fisher-Yates Shuffle pseudokod}
\label{alg:wheel}
\begin{algorithmic}[1]
\Require En kortlek $H1$
\Ensure Blandad kortlek $H3$ 
\State $I \gets$ lista med index $0$ till $51$ \Comment{Skapa en lista med index}
\State FisherYatesShuffle($I$) \Comment{Blanda indexen slumpmässigt}
\State $H2 \gets$ ny lista med $52$ platser \Comment{Skapa 'wheel' med plats för varje kort}
\For{$i \gets 0$ till $\text{längden av } D - 1$}
    \State $idx \gets I[i]$ \Comment{Välj ett slumpmässigt index från $I$}
    \State $H2[idx] \gets D[i]$ \Comment{Placera kortet i 'wheel' baserat på slumpindex}
\EndFor
\State $H3 \gets H2$ \Comment{Uppdatera $H3$ med den nya ordningen från 'wheel'}
\end{algorithmic}
\end{algorithm}

% \begin{wrapfigure}{r}{0.6\textwidth}
\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\linewidth]{irl_wheel_shuffle.pdf}
	\captionsetup{width=0.6\textwidth} \caption{Ett illustrativt diagram av
		kortblandningsprocesen med 
	Fisher-Yates metoden. Fundamentala mekaniska komponenter till den potentiella
	kortleksblandaren, där sträck är kort, cirkelformen är roterande
kortmatningsmekanismen. Med två högar, $H1$ och $H3$. Där $H2$ har ett fack för
varje kort, d.v.s. 52 stycken. Och $H3$ är plats till en blandad kortlek.}
	\label{fig:irl_wheel}
\end{figure}
% \end{wrapfigure}
% \noindent

% \clearpage

\subsection{Simulering av kortblandningsprocesser}
\label{sec:sim_kort}
Simulations- och blandningsalgoritmerna implementerades i programmeringsspråket
Rust version 1.73.0. Rust valdes p.g.a. dess robusta stöd för abstraktioner utan bekostnad.  
% Datan insamlades från digitalt simulation på olika kortblandningsmetoder
% i Rust version 1.73. De algoritmerna som undersöktes var skrivna i
% programspråk Rust i försök att göra dem så likt verkligheten som
% möjligt. 

% \lstinputlisting[language=Python, caption={Pile Shuffle skriven i
% Rust},label=selection-sort, label={lst:algo_2},firstline=329,
% lastline=335]{../randomness/sim_stats.py}

% För statistikst analys av data användes programmeringsspråket Python
% 3.11 och utnyttjades bibliotek som Numpy till datamängd bearbetning,
% Scipy till statistisk analys och Matplotlib till visualisering av
% resultat. 

% Den Valdes på grund av dess breda användning inom vetenskapligt
% forskning  och dess omfattande bibliotek för numerisk analys.  

% och användes bibliotek (Rust Crates) som Rand version 0.8 för PRNG
% \parencite{rand_crate}. Rayon för enkel användning av  parallell
% multiprocessing
% \parencite{rayon_crate}.
Simulationen avspeglar hur ett fysiskt kortleksblandare skulle fungera. Därför
togs det valet att alla simulationer ska ha ett och samma utgångspunkt. Därmed i
analysen kan det jämföras olika metoder beroende på deras iterationer. D.v.s. ett verkligt
scenario simulerades vart ett helt ny oöppnad kortlek skulle placeras i den
potentiella kortleksblandare. Den ordning kallas för ett fabriksordning för
en standard 52-kortlek. Där korten är ordnade efter sin färg i sekventiell
ordning från två till ess (utan jokrarna). Matematiskt kan detta ordningen
beskrivas som mängden $\{x \in \mathbb{N},  0 \leq x \leq 51 \}$, där $x$
representerar en enskild kort och vart ordningen spelar roll. 

För att bestämma datamängden d.v.s. antal kortlekar per en simulation. Användes
det rekommendationen för chi-två-testet. Där NIST redogör för att minsta förekommande
kategorin för pokertest borde inte vara mindre än 5 stycken (se sektion
\ref{sec:chi_square}). 
% Simulation utgår från att man genererar
% tvådimmensionella array, detta kan matematikst beskrivas som matris med
% bestämd mängd av kortlekar. Vart varje kort, låt kalla dem till $x$ som
% följer följande mängden $\{x \in \mathbb{N},  0 \leq x \leq 51 \}$
% Resulterande datamängden är en \gls{matris} $D$ med 52 kolumner och $m$ antal
% rader, vart $m$ värde visar hur många kortlekar det finns i datamängden.
% För att bestämma värdet för $m$ följdes ett kriterium ifrån klassiskt
% poker test (mer i  detalj beskriven i underrubriken
% \ref{sec:chi_square}).
% Till hjälps användes NIST internätkälla   i
% denna nämns det att det är viktigt för chi-square approximationens trovärdighet
% att minsta kategorin ska inte vara mindre än fem teoretiska framkommande i den
% kategorin \parencite{nist}. Därför är det
% viktigt att hitta den minsta kategorin som kan förekomma.
I poker är den mest
sällsynta pokerhanden Royal Flush och det finns 4
stycken av dessa i en standardkortlek. Den teoretiska sannolikheten att
få 5 Royal Flushes per $m$ kortdelningar kan approximeras på följande sätt: 
% som kan räknas ut på
% följande sätt antal av alla kortkombinationer med fem kort. $\binom{52}{5} =
% 2\,598\,960$ Kungliga färgstege finns det fyra  kombinationer av i kortleken
% som kan räknas ut på följande sätt totala antal kombinationer av kungliga
% färgstege delat med totala antal femkorts kombinationer från standardkortlek.
$$ P(\text{Kunglig färgstege}) =  \frac{\binom{4}{1}}{\binom{52}{5}} =
\frac{4}{2\,598\,960} \approx \frac{1}{649\,740} $$ 
Resultatet skalas med faktor av 5:
$m = P(\text{Kunglig färgstege})^{-1}  \times 5 = 3\,248\,700$.
Den resulterande värden på $m$ används som den absoluta längden av datamängden i
simulationen. För att visualisera detta, låt $D$ vara en \gls{matris} 
med 52 kolumner (antal kort i standardkortleken) och $m$ antal rader (längden av
datamängden), och där $x$ är en av talen ur den tidigare definierade mängden.
\begin{equation*}
	D = \begin{bmatrix}
		x_{0,0} & x_{0,1} & x_{0,2} & \cdots & x_{0,51}\\ 
		x_{1,0} & x_{1,1} & x_{1,2} & \cdots & x_{1,51}\\
		x_{2,0} & x_{2,1} & x_{2,2} & \cdots & x_{2,51}\\
		\vdots & \vdots & \vdots & \; & \vdots \\
		x_{m,0} & x_{m,1} & x_{m,2} & \cdots & x_{m,51}
	\end{bmatrix}
\end{equation*}

% \subsubsection{Val av datatyp \& rådatalagring} 

% Efter teoretiska beräkningar av
% datamängden är det viktigt att välja en lämplig datatyp att representera data i.
% Högsta talet som behövs är 51 definerad tidigare och betecknat med $x$. Detta
% betyder att den minsta datatypen som får användas är 8 bit eller 1 byte långa som
% kan  innehålla följande värden $$\{b \in \mathbb{N},  0 \leq b \leq 255 \}$$ som
% överns\-stämmer med datamängdens högsta talet $x$. Detta ger möjligheten att
% använda den  fundermantala datatypen som används i minnesadressen. Fördelen med
% detta är det simplifierar lagring och inmatning av datamängder i t.ex Python
% med NumPy.
Via experimentell metodik valdes det att utföra 15 iterationer
per algoritm. En iteration definieras till att kortleken blandas successiv på
föregående blandning. Detta gjordes 
för att senare kunna jämföra hur algoritmens slumpmässighet påverkas av ökande 
antal iterationer. Dessutom kan detta valet motiveras av att \gls{gsr}s matematiska
modellen visar sig vara mest effektiv vid 7 och 11 iterationer (se sektion
\ref{sec:riffle_shuffle}). Detta antal iterationer kunde
ske p.g.a. att simulationsprocessen effektiviserades med Rayon \gls{crate}.
% simulationen 
Med detta verktyg utfördes programmet i parallellt exekvering. 
% På ett
% effektivt sätt simulerades det mer data.
% Detta valet
% togs för att algoritmerna är oberoende av varandra.
% och att på detta sättet
% .  
% Därfor mer iterationer utfördes och
% på så sätt mer data insamlades.
% Därför infördes
% det 4 iterationer till för mer analysdata.

För att förutspå hur mycket RAM och hårddisk minne  skulle eventuellt användas vid
lagring och dataanalys. Räknades tyngden av vad datamängd ska väga 
% Där ett kort är representerat i uint8
% (8-bit lång datatyp)
% användes. Tynged av datan räknades till
% Andra aspekten till varför datatypen är viktigt är att spara minnen för att det
% kommer att simuleras och sparas tiotals rådata filer varje fil kommer att väga
$161 MB$ vid användning av 8-bit datatypen.
$$ \frac{\text{totala bytes}}{\text{megabyte (MB)}} = \frac{52 \times m }{1024 \times
1024} = \frac{52 \times 3\,248\,700}{1024 \times 1024} = \frac{168\,932\,400}{1\,048\,576} \approx 161 MB 
$$
Detta steget behövdes för att ta ett informativt beslut senare. D.v.s. hur data ska
analysers och eventuella anpassas.
% och proccessen effektiviseras.   

Som det tidigare nämndes utfördes simulationen parallellt, varje algoritm
exekverades på egen tråd, oberoende av varandra.
Simulationen utfördes i följande steg: 
1) Algoritmerna sparades i en lista;
2) En lista av kortlekar, motsvarande matrisen $D$ med $m$ antal kortlekar, initierades till fabriksordningen; 
3) Algoritmerna itererades i en nästlad loop från $i = 1$ till $i = 15$; 
4) Ledtidsmätaren sätts igång;
5) Denna iterationsvariabel $i$ användes för att iterera över listan av kortlekar
och utföra blandningen $i$ gånger;
6) Efter varje iteration $i$ adderades ledtiden;
7) Efter avklarad iteration $i$ medelvärde av ledtiden kalkylerades och
sparades i en csv fil;
8) Resulterande blandade kortlekarna plattades ut till en endimensionell lista;
9) Denna endimensionella lista sparades som en binärfil för statistisk analys.

% som det är enkelt att spara data i binärt format för att 8 bits eller 1 byte
% är ett fundamentalt och uniformt mått i minnesadressen. Med det sagt, ingen
% bearbetning av data behövs och det är enkelt att ladda in denna i till exempel Python
% med numpy till statistiska testerna av rådata
%
% Därför att sista teoretiska delen att bestämma
% är hur många iterationer per algoritm ska genomföras. Med iterationer menas
% hur många gånger kortleken blandas följande på varandra.


\subsection{Statistisk analys av insamlad data.}
Denna sektion handlar om hur statistiska metoder som Pokertest och
\gls{stdmean} test implementerades för att analyser slumpmässighet av valda och
simulerade algoritmerna. Statistiska tester utfördes med Python version 3.11.
Python valdes p.g.a. dess breda användning vid statistisk analys (se sektion
\ref{sec:verktyg}).

Efter simulationen, genererade mängderna laddades in i Python-program och sedan återställdes tillbaka till
formen av matrisen $D$ från sektion \ref{sec:sim_kort} med hjälp av NumPy för vidare
bearbetning. Analysmetoderna delar inladdad data p.g.a. optimeringsskäl som e.g.
spara minne och minimera initial exekveringstid.

På grund av begränsad kunskap inom avancerad statistisk matematik,
även om metoder som Approximate EntropY (\gls{apen}) skulle kunna erbjuda
ytterligare insikter i slumpmässighets analys \parencite{ApEn}, valdes det att
inte använda dem i denna studie. Därför ligger fokus på en
annan gren av slumpmässighet baserad på
sannolikhetslära. % (se \ref{sec:slump})

% områden inom matematiken som statistikt analys. Detta betyder att rent
% matematiska modeller till avgörande av slumpmässighet som approximate
% entropi (\gls{apen})   Men den 

% Men för att avgörande av
% slumpmässighet är domän specifikt och rent matematiskt komplex då krävs
% det högre förstålse i matematatikens området inom statistik.  Istället
% valdes det att fokuser på normal distrabition av kortlekar och kort.
% Dessutom implementerades det metoder som är visuellt representativa.

% Från
% andra sidan är simulation enklare att utföra och analysera data med
% avseende på förväntade frekvensen ($\chi^2$-testet) samt enklare
% statistiska koncept som mediana och standardavviklse (StdMean-testet).


% För statistikst analys av data användes programmeringsspråket Python
% 3.11 och utnyttjades bibliotek som Numpy till datamängd bearbetning,
% Scipy till statistisk analys och Matplotlib till visualisering av
% resultat. 

% med följande
% metoder: Klassisk Poker Test \ref{sec:poker_test} och medelvärde av
% korta positioner i kortleken över hela datamängden kalkylerad såsom
% avvikelser av dessa positioner. Utförligt beskrivning i underrubriker. 

\subsubsection{Implementation av klassiska pokertestet}
\label{sec:poker_test_M}
Syfte med denna metod är att utföra preliminär gallring av algoritmernas
iterationer som har betydande avvikelser från dem förväntade värdena av en slumpmässigt
blandningsalgoritm.  

Klassiska pokertest utgår ifrån att man karaktäriserar typer av mönster
till pokerhänder och kalkylerar  den absolut värde av $\chi^2$ i detalj beskrevs
teorin bakom chi-två-test  i sektion \ref{sec:poker_test}. Klassiska pokertestet 
i denna studie baseras på faktumet att simuleringar utfördes med en
standard kortlek. Därför valdes det att anpassa chi-två-testet att använda alla
pokerhänder. Matematiken, speciellt kombinatoriken att räkna ut sannolikheter
och frekvensen av alla poker\-händer är relativt svår uppdrag därför
adopterades det uträkningar ifrån studie av \textcite{Drew2006}, se Tabell
\ref{tab:all_poker_hands}. Detta metodiken medföljde med mer komplex
karakterisering av poker\-händer än när man använder chi-två-testet till att
e.g. testa slumptalsgeneratorer. Motiveringen till komplexiteten var att i denna
studie utforskas särskilt kortlekar till spel varav kombinationer av kort ofta
spelar betydande roll och därför var det särskilt viktigt att anpassa metoden för slumpmässighets analys till hur den potentiella kortleksblandaren skulle
fungera i drift.

\begin{table}[H] 
\captionsetup{width=0.5\textwidth, justification=centering}
\caption{Namn på alla pokerhänder och dess relativ mönster. Antal$_1$ är 
teoretisk framkommande kombinationer med en standard kortlek. Antal$_2$ är 
faktoriserade kombinationer d.v.s. \\ Antal$_2 = $ Antal$_1 \times 1.25$ }
\label{tab:all_poker_hands}
	\centering
	\begin{tabular}{|l|c|r|r|}
	
	% Header
	\hline 
	Pokerhand 
	& Exempel mönster
	& Antal$_1$ 
	& Antal$_2$ 
	\\ \hline  

	% rows
	Royal Flush 
	& $A\spadesuit\, K\spadesuit\, Q\spadesuit\, J\spadesuit\, 10\spadesuit$
	& 4 
	& 5
	\\ \hline

	Färgstege
	& $K\spadesuit\, Q\spadesuit\, J\spadesuit\, 10\spadesuit\, 9\spadesuit$
	& 36 
	& 45
	\\ \hline

	Fyrtal 
	& $A\spadesuit\,A\heartsuit\,A\diamondsuit\,A\clubsuit\, K\spadesuit$ 
	& 624 
	& 780
	\\ \hline

	Kåk 
	& $A\spadesuit\, A\heartsuit\, A\diamondsuit\, K\clubsuit\,K\spadesuit$ 
	& 3\,744
	& 4\,680
	\\ \hline

	Färg
	& $K\spadesuit\, Q\spadesuit\, J\spadesuit, 10\spadesuit\, 8\spadesuit$
	& 5\,108
	& 6\,385
	\\ \hline

	Stege 
	& $K\spadesuit\, Q\heartsuit\, J\diamondsuit\, 10\clubsuit\,9\spadesuit$ 
	& 10\,200
	& 12\,750
	\\ \hline
	Triss 
	& $A\spadesuit\, A\heartsuit\, A\diamondsuit\, K\clubsuit\, Q\spadesuit$
	& 54\,912
	& 68\,640
	\\ \hline

	Två par 
	& $A\spadesuit\, A\heartsuit\, K\diamondsuit\, K\clubsuit\, Q\spadesuit$
	& 123\,552
	& 154\,440
	\\ \hline

	Ett par 
	& $A\spadesuit\, A\heartsuit, K\diamondsuit\, Q\clubsuit\, J\spadesuit$ 
	& 1\,098\,240 
	& 1\,372\,800
	\\ \hline

	Högt kort
	& $A\spadesuit\, Q\heartsuit\, J\diamondsuit\, 5\clubsuit\, 4\spadesuit$
	& 1\,302\,540
	& 1\,628\,175
	\\ \hline

	 
	\multicolumn{2}{|r|}{Summan:} 
	& 2\,598\,960 
	& 3\,248\,700
	\\ \hline
\end{tabular}
\end{table}

\noindent
Kategoriseringsprocessen till att få en hand till en pokerhand började med
att utnyttja dem vektoriserad aritmetik funktionaliteterna NumPy har. Med denna 
funktionen valdes det på ett effektivt sätt ut fem kort i.e. en hand och kördes igenom
en kategoriserings funktion om denna senare. De fem korten valdes ut på ett
speciellt sätt för att göra denna likvärdig verkligheten. D.v.s. pokerspel med 2
spelare. Där valdes det kort med index 0, 2, 5, 6 och 7 (spelare-ett:  2 kort i
handen, spelare-2 kort förkastas och 3 sista kort är flop) med NumPy funktionalitet
kördes kategoriserings funktionen radmässigt.

\textbf{Kategoriserings funktion:}
I standardkortlek finns det 52 kort med fyra olika 
färger (Spader, Hjärter, Ruter och Klöver) och 13 valörer 
(2, 3, 4, 5, 6, 7, 8, 9, 10, Knekt, Dam, Kung, Ess). Konvertering av tidigare
definierade mängden av kort $x$, i.e. (0, 1, 2, $\dots$, 51) till kategoriserade
kort utfördes. För att optimera kategoriseringsproccessen användes Numba för att skapa en
ny tråd, detta kunde enbart göras p.g.a. att det användes NumPy 8-bit datatyp, som definierades tidigare. Efter att en ny tråd skapades fortsattes processen på följande sätt: 
\begin{equation}
    \text{valör}(x) = x \mod 13
\end{equation}
\begin{equation}
    \text{färg}(x) = \left\lfloor \frac{x}{13} \right\rfloor
\end{equation}
Där $\text{valör}(x)$ ger värde från 0-12 och $\text{färg}(x)$ ger värde från
0-3. För dem intresserade av specifika kod detaljerna se Bilaga
\ref{app:github}. Fortsättningsvis gav denna funktion tillbaka ett värde från
0-9 som indikerar ett pokerhand ifrån Tabell \ref{tab:all_poker_hands}, där 0 är
Högt kort och 9 Royal Flush. För att denna funktionen kördes kolumnmässigt över
hela datamängden var denna resulterande 
lista med antal observerade pokerhänder från varje rad, låt denna lista betecknas till
$O$ (Observerat frekvens). I bästa fall skulle denna lista
fått likadana värdena som kolumnen Antal$_2$ i Tabell \ref{tab:all_poker_hands}.


\textbf{Chi-två-test}: Inställningar till testet var $\alpha = 0.05$
(\gls{alfa}), df $= 10 -
1 = 9$ (frihetsgrader), där $10$ är den antal pokerhänder givna av Tabell
\ref{tab:all_poker_hands}. Sedan beräknades gränsvärde med SciPy \gls{bibliotek}s
funktionen $Chi2.ppf( 1 - \alpha, df)$. Sedan används det \textit{chisquare}
funktionen ifrån SciPy för att beräkna \gls{pvalue} och $\chi^2$ värde. För att
kalkylera denna användes tidigare genererade listan $O$ och dem förväntade värden given av
kolumnen Antal$_2$ i Tabell \ref{tab:all_poker_hands}. Resulterande värdena på
\gls{pvalue} och $\chi^2$ sparades i en csv fil för redovisningen i Resultat
sektionen.

\subsubsection{Implementation av STDMean testet}
Syfte med denna analysmetod är att utforska hur enskild kort rör sig genom
kortleken när den blandas. Därmed avgöra om algoritmen har eller inte har en
tendens att blanda specifika delar av kortleken mer än dem andra. Det här är i sin
tur särskilt viktigt då på positionen på det första korten har en betydande roll i spelets rättvisa. Snedvridningen kan alltså
potentiell indikera logiska fel i implementeringen av en algoritm. I initiala
tester användes \gls{stdmean} testet för att upptäcka logiska fel. Detta hände i
den första versionen av implementation av \gls{gsr} Riffle Shuffle, där det på
fel sätt användes indexering i iterationen, felet upptäcktes med hjälp av denna
analysmetoden. 

För att förstå metoden är det relevant att återbesöka konceptet med matrisen $D$
i sektion \ref{sec:sim_kort}. Därför att det utnyttjade NumPy vektoriserad
aritmetik i symbios med dess inbyggda funktioner som medelvärde och
standardavvikelse. Både funktionera utfärds kolumn vis på $m$ antal rader.
Denna resultatet användes sedan till att rita punktdiagram av Medelvärde av
Position (\gls{mp}) på y-led  och Position av Kort (\gls{pk}) på x-led med hjälp
av matplotlib. Standardavvikelse av \gls{pk} visas som vertikal symmetrisk linje
ifrån \gls{pk} punkten. Den teoretiska medelvärdet i en slumpmässigt blandning
borde ligga runt $51 \div 2 = 25.5$ och den experimentellt testade \gls{sd}
ifrån \gls{pk} $\approx 15$.

\section{Resultat}
% Result är icke bestämt i vilken format kommer att skrivas
% Men dem kommer att innehålla figur \ref{fig:test_figure}. Antagligen mest 
%intresanta figurer kommer att visas här och alla andra Bilagas i Appendix.
%För att det kommer att vara minst 30 figurer och chi två tabeller(dem 
%kan göras i ett större tabell, antar jag)


Totalt 50 simulationer utfördes. 15 simulationer per algoritm för att jämföra
samma algoritm med olika antal iterationer, varje algoritm har alltså resultat
som motsvarar utförsel med iterationer 1-15. De mest relevanta resultaten av
simulationerna plockades ut och presenteras här. Resultat av pokertest samt
medelvärde för algoritmers ledtid presenteras i tabellen nedan. Resultaten
av STDMean testet visas i Bilaga \ref{app:stdmean}. Vilket kort som en punkt i
diagrammet representerar ges av punktens position på x-axeln, medelvärde är
avläst från punktens position på y-axeln och standardavvikelse är givet av den
symmetriska vertikala linjen som går genom punkten.

\textbf{\gls{gsr} Riffle Shuffle}: Pokertestet visade en varierande slumpmässighet
med första giltiga resultat vid iteration 7, efter det försämrades slumpmässigheten.
Speciellt iteration 9 som översteg gränsvärdet på 16.92 men efter denna iteration förbättrades
resultaten igen. Ledtiden visade ett stabilt värde men efter iteration 9 minskade
ledtiden med ca 15\% relativt till iteration 3 (se Tabell
\ref{tab:gsr}).
Resultat av STDMean testet visade en stigande trend av medelvärde av position
(\gls{mp}) över position av kort (\gls{pk}) samt dess standardavvikelse
(\gls{sd}) var jämnt för alla \gls{pk}. Iteration 3 visade ett stigande trend (se
Bilaga \ref{app:stdmean} \ref{fig:gsr-3}) men vid iteration 7 normaliserades denna
till det teoretiska beräknade värdet av \gls{mp} = 25.5 (se Bilaga
\ref{app:stdmean} Tabell \ref{fig:gsr-7}). 

\textbf{Six Pile Shuffle}: Iteration 1 och 2, pokertestet visade att $\chi^2$
värdena låg över gränsvärden. Iteration 3 visade det första giltiga resultatet.
Vid nästkommande iterationer låg gränsvärden inom normen, med ingen
tydlig trend. Vid ökade iterationer  ledtidenerna verkar varit konstanta med
minimal variation på ca +8\% mellan iteration 1 och 7 (se Tabell \ref{tab:six}).
STDMean testet vid iteration 1 visade värdena av stor betydelse, var \gls{pk} 0-2
hade låg \gls{sd} värde ca 5.4 vid \gls{pk} 1 och ca \gls{sd} 9.0 vid \gls{pk} 2
d.v.s. värden ökade i det här intervallen med \gls{sd} ca 2.0
(se Bilaga \ref{app:stdmean} Tabell  \ref{fig:six-1}).
Sedan dess värdena varit varierande som liknade sinusfunktion. Men vid \gls{pk}
49-51 visades det exakt likadant mönster som i \gls{pk} 0-2. Vid iteration 2 plattades
värdena men vart tionde \gls{pk} hade avvikelser i \gls{mp} 
(Bilaga \ref{app:stdmean} Tabell  \ref{fig:six-2}). Sedan vid iteration 3, detta
mönstren minskades (Bilaga \ref{app:stdmean} Tabell \ref{fig:six-3}).
Sedan vid iteration 4 plattades \gls{mp} värdena helt och var
vid den teoretiska värden av \gls{mp} (Bilaga \ref{app:stdmean} Tabell \ref{fig:six-4}).

\textbf{\gls{soc} Pile Shuffle}: Från pokertestet, första giltiga resultat
visades vid iteration 2. Medans i iteration 3 överstig gränsvärden medans dem
successiva iterationer låg $\chi^2$ värdena inom den kalkylerade gränsvärden.
Ledtiden från iteration 7 visade likadan  variation på +8\% relativt till
iteration 1 (se Tabell \ref{tab:soc}). Resultatet av STDMean testet iteration 1
visade samma mönster som i Six Pile Shuffle. För \gls{pk} 0-2 och 49-51 men
\gls{sd} av \gls{pk} 0 och 51 var med ca 2.0 större än i Six Pile Shuffle
(Bilaga \ref{app:stdmean} Tabell \ref{fig:soc-1}). Medans \gls{pk} från 15-36
hade \gls{mp} som låg runt 25.4. Iteration 2 hade synlig avvikelse av \gls{mp}
för \gls{pk} 0 och 51. Annars enbart \gls{pk} 10 och 41 hade synlig avvikelse
från den teoretiska \gls{mp} (Bilaga \ref{app:stdmean} Tabell \ref{fig:soc-2}).
Iteration 3 hade endast första och sista \gls{pk} som hade synlig avvikelse från
\gls{mp} (Bilaga \ref{app:stdmean} Tabell \ref{fig:soc-3}). Medans vid iteration
4 låg alla \gls{mp} på den teoretiska värden (Bilaga \ref{app:stdmean} Tabell
\ref{fig:soc-4}).

\textbf{Ten Pile Shuffle}: Iteration 1 enligt resultatet av pokertestet visade
en icke slumpmässigt iteration. Med första giltiga resultat var vid iteration
2. Dessutom iteration 2 till 5 visade stabila $\chi^2$ värden runt 5.28
(medelvärde av dess 4 iterationer). Ledtiden hade likadan trend som föregående
Pile Shuffles d.v.s. ökat värde på ca 8\% från iteration 1 till 7 (se Tabell
\ref{tab:ten}). \gls{stdmean} testet vid iteration 1 visade likadan \gls{sd}
mönster för \gls{pk} men vid högre \gls{mp} värdena än SOC Pile Shuffle (Bilaga
\ref{app:stdmean} Tabell \ref{fig:ten-1}). Samt iteration 2 hade likadan mönster
(Bilaga \ref{app:stdmean} Tabell \ref{fig:ten-2}). Medans iteration 3 hade
väldigt liten avvikelse i \gls{pk} 0 och 51 (Bilaga \ref{app:stdmean} Tabell
\ref{fig:soc-3}). Vid iteration 4 var alla \gls{mp} värdena vid den teoretiska
värden (Bilaga \ref{app:stdmean} Tabell \ref{fig:soc-4}).


\textbf{Wheel Fisher-Yates Shuffle}: Alla iterationer var inom gränsvärden d.v.s.
hade giltiga resultat enligt pokertestet. Men vid iteration 3 och 6 $\chi^2$
värdena var relativt lägre än dem andra. Ledtiden från iteration 1 till 7 hade
ett ökat värde på ca 9\% (se Tabell \ref{tab:wheel}). STDMean testet visade att
dess \gls{mp} låg vid den beräknade värde redan vid första iteration såsom vid
samtliga successiva iterationer (se Bilaga \ref{app:stdmean} Tabell
\ref{fig:wheel-1}). 

\input{resultat_chi_square}

\section{Diskussion}
Diskussion om resultaten av simulationerna är uppdelat i flera underavsnitt i
syfte att göra det enklare att följa tankeprocessen.
% Den
% första subsektionen(\ref{sec:d_bm}) handlar om hur den mest passade
% blandningsmetoden togs fram, den är uppdelad i två delar. 
I jämförelsen av
blandningsmetoderna(\ref{sec:d_bm_jbm}) kommer närmare undersökning av metoderna
komma fram till vilken av dem som passar bäst inpå dem krav som ställdes i
syftet (\ref{sec:purpose}). Felkällor (\ref{sec:d_fk}) nämns efter att den mest
passande blandningsmetoden tagits fram för att diskutera deras påverkan på dem
tidigare slutsatserna i diskussionen. I slutsatsen (\ref{sec:d_s})
återpresenteras den blandningsmetod som undersökningen kom fram till vad det
innebär och vilka förbättringar som skulle kunna göras i potentiell framtida
forskning.

% \subsection{Den mest passande blandningsmetoden}
% \label{sec:d_bm}

\subsection{Jämförelse av blandningsmetoderna}
\label{sec:d_bm_jbm}
%no.1 priority probably
\textbf{Utifrån slumpmässighet}: Resultaten av det klassisk pokertestet (Tabell
\ref{tab:res-pokertest}) ger ut vilka av blandningsmetoderna som kan definitivt
inte sägas ge slumpmässigt blandade kortlekar.
% dem som var signifikanta.
Eftersom den bästa blandningsmetoden måste kunna slumpmässigt blanda en kortlek.
Därför är ingen av metoderna som gav signifikanta resultat d.v.s. dessa som
överstiger gränsvärde på 16.92 värda att tänka på, dem kan gallras från
populationen av metoderna som behöver vidare analys. För GSR Riffle Shuffle
betyder det att alla innan 7 kan gallras bort, det är ett logiskt resultat då det
stämmer överens med tidigare undersökningar på GSR vars resultat också medför
att 7 upprepningar av Riffle Shuffle krävs för att få en helt slumpmässig
blandning \parencite{dovetaillair}. Ten Pile Shuffle visade det mest säkraste
indikation på hög slumpmässighet vid iterationer 2 till 5 men enligt
STDMean testet var det endast med fyra iterationer som alla kort i kortleken hade tillräckligt stort variation d.v.s. ingen avvikelse från dem teoretiska värdena.
SOC Pile shuffle visade också giltigt slumpmässighets värde vid iteration 2 men
såsom med Ten Pile Shuffle endast iteration 4 visade helt slumpmässigt resultat
från STDMean testet. Six Pile Shuffle vid pokertestet gav giltiga värdena som
dem andra variationer endast iteration 5 visade giltigt resultat enligt STDMean
testet.  

%Dem algoritmer som gallras är dem som helt säkert inte kommer vara bättre en dem
%andra i dem färdigheterna som blandningsmetoderna jämförs på. Alla blandningsmetoder 
%som var signifikanta enligt det klassiska poker testet(\ref{sec:poker_test_M}) kan 
%gallras då dem inte uppnår ett av kraven för blandningsmetoder(\ref{sec:purpose}),
%dem blandar inte på ett helt slumpmässigt sätt.

\textbf{Baserad på dess effektivitet}: Eftersom 
den potentiella kortleksblandaren prioriterar effektiviteten av blandningen kan blandningsmetoderna bedömas utifrån mängden successiva blandningar (iterationer) dem utför. Blandningsmetoder som utför fler iterationer kommer vara något mindre effektiva än metoder av samma typ men som utför färre iterationer, d.v.s. ett lågt antal iterationer är en fördel. På grund av det så kan alla blandningsmetoderna som utför mer än tio iterationer konstateras innehava en underlägsen effektivitet utan noggrannare analys. Dessutom visades dem inte ökat slumpmässighet med över 11
iterationer. Med detta sagt iterationer från 11 till och med 15 iterationer är
alltså inte inkluderade i den närmare analysen.

Algoritmerna presterade med olika slags mjuvarassnabbhet. GSR Riffle Shuffle var
den näst långsammaste men ledtiden minskade vid mer iterationer. Detta kan
beror på att alla algoritmerna kördes i parallellt simulation därför friades det
mer resurser åt dem sista iterationer. Six Pile Shuffle enligt ledtiderna var
den snabbaste detta kan bero på att algoritmen hade mindre fack att välja mellan
dessutom stannade algoritm färre gånger. D.v.s. när ett annat fack är redan
fullt av dem max 10 kort per fack. SOC Pile Shuffle presterade sämre än GSR. Ten
Pile Shuffle var den mest långsammaste och dess ledtid ökade vid fler
iterationer. Detta kunde också påverkas av faktumet på inte tillräckligt likt
till den potentiella kortleksblandare metod.

Ledtiderna för Wheel Fisher-Yates proccessmässigt kunde inte simuleras på likt
som den potentiella blandningsmaskinen. För att processen att simulera detta
blev svårare och löstes inte.  Därför dess ledtiden kan inte vara ett mått på
dess effektivitet.

Dessutom ledtiderna kan vara vilse ledande. Detta kan beror på att
simulerings miljö inte riktigt avspeglade hur den potentiella kortleksblandare
skulle ha fungerat. Därför blandningsmetoderna effektivitet diskuteras i nästa
del.


\textbf{Ifrån dess fysiskt tillämplighet}:
Som det nämndes i sektion \ref{sec:algos} dessa tre undersökta algoritmerna har
väldigt annorlunda design principer därmed behöver olika antal av rörliga delar
involverade i processen för att imitera dess underliggande algoritm. Dessa
faktorer kommer att påverka dess fysiska tillämplighet i den potentiella
blandningsmaskinen. Därför önskade faktorerna som storlek, snabbhet och
verkställbarhet (hur enkelt är dess design och  hur framgångsrik kan den utföra
successiva iterationer utan problem) ska tänkas innan valet görs. Men för att
dessa krav undersöks inte i denna studie kan inte den bästa blandningsmetod tas
fram. Därför i denna studie har det kommits fram till att det finns ingen
definitiv svar men snarare ett eller annat metod kan vara mer eller mindre
passande. GSR visade att den behöver 7 iterationer för att nå slumpmässig
blandning. För effektiviteten innebär det ett långt blandningsprocess. Dess
fysiska tillämplighet är komplex. Den behöver två kortmatningsmekanismer som
fungerar i symbios med varandra för att eliminera tidsrelaterade problem. Pile Shuffle
har relativt lätt framtagningsprocess och har redan 3D printats av
\parencite{3DprintedLife2021}. Den är effektivt för att den kräver endast en
kortmatningsmekanism, ingen tidsrelaterade problem finns för att det är endast ett kort
som rör sig i taget. Men för den mest slumpmässiga resultat med minsta antal
iterationer ska SOC inte användes. Istället Ten Pile Shuffle ska tillämpas för
att den visade mer stabila resultat i pokertestet. Därför är denna algoritm mer
pålitlig att ha högre slumpmässighet. Om kravet är att blanda flera
kortlekar kan Wheel Fisher-Yates Shuffle tillverkas.  Angående effektivitet kommer
denna att vara långsamt p.g.a. den måste snurra för att mata in en kort i
rätt position. Men den behöver endast en kortmatningsmekanism. Samt endast ett
iteration för att nå slumpmässig blandning.


\subsection{Felkällor}
\label{sec:d_fk}
Som det nämndes i föregående sektion ledtiderna visar inte rätt representation av
hur långt tid det tar för att utföra en blandning. Samt simulationen avspeglar
inte hur långt tid denna skulle ta i verkligheten. Därför ledtiderna blev
relativa men kunde inte användes för att argumentera för en eller annan
kortleksblandare skulle vare mer effektiv.

I denna studie saknades det kunskaper om andra statistiska analysmetoder som
ApEn som skulle ha gett inblick i andra aspekter av algoritmens slumpmässighet.
Dessutom datamängd som valdes ifrån i krav pokertestet skulle ha varit högre
för att uppnå mer testdata. På så sätt få att Royal Flush, matematiskt skulle ha
uppkommit fler än 5 gånger. Detta skulle ha get mer pålitliga testresultat.

% Simulerings proccesesn aviker från verklighet. Generel kunnigethet om området
% under framtällandet av metod och analys av resulat. Datamängden skulle vara
% högre, vi gjorde att det teoritsk kan framkomma 5 Royal flushes men det kan vara
% en större mängd då kanske blir pokertestresultat mer pålitliga.


\subsection{Slutsats}
\label{sec:d_s}
%this section is kerkalicious
I studien undersöktes 3 olika design av blandningsmetoderna- Riffle Shuffle, Pile
Shuffle (med 3 olika variationer) och Wheel Shuffle. Utifrån resultat av
statistiska analysmetoder som Pokertest och STDMean testet har det kommits fram
till mest passande antal iterationer. Men en definitivt bästa blandningsmetod
till den potentiella kortleksblandare kunde inte tas fram. Istället varje
blandningsmetod kan användes vid specifika krav, dessa krav undersöktes inte.
Därför är den enklaste metoden att tillverka Pile Shuffle med 10 fack och 10 max
kort per fack. Dessutom för den mest slumpmässiga kortleksblandning ska
kortleken blandas 4 gånger. Om istället kravet ligger att blanda mer en
kortlek då skulle Wheel Shuffle med Fisher-Yates blandningsalgoritm passa bäst
den skulle endast kräva 1 iterationer för att vara tillräckligt slumpmässig.
Slutligen Riffle Shuffle kräver mer undersökningar därför att 7 iterationer är
tidskrävande d.v.s. inte effektivt samt design av en sådan maskin är mest komplex
av dem 3. Såsom denna metod ska behöva 2 kortmatningsmekanismer samt ska denna
kunna utföra blandningar utan att få tidsrelaterade problem.

I framtida forskning skulle Riffle Shuffle undersökas närmare, andra variationer i
algoritmen testas för att nå tillräckligt stort slumpmässighet med färre
iterationer på så sätt dess effektivitet förbättras. För Pile Shuffle and Wheel
Shuffle skulle prototyper byggas för att undersöka dess riktiga ledtider i ett
fysiskt maskin. På så sätt dess fysiskt tillämplighet undersökas närmare. Samt
prototyper skulle byggas i 3D modellerings program och sedan program som Gazebo simulator användas för att simulera dessa i sin fysiska form men i
en simulation som simulerar vår fysiska värld på mer tillfredsställande sätt.

%\nocite{*}


\printbibliography[heading=bibintoc, title={Bibliografi}]
% \newpage

\appendix
\section*{\appendixpagename} 
\addcontentsline{toc}{section}{\appendixpagename} 

\section{Källkod}
\label{app:github}
Länk till Github repository vart Rust och Python källkod till simulationen 
respektive statistisk analys är samlad, samt källkod till latex med
vilken detta rapport hade skrivits
länk: https://github.com/Abishevs/gymnasieArbete_23-24

\section{Kod för GSR Riffle Shuffle}
\label{app:gsr}
\lstinputlisting[language=Rust, caption={Pile Shuffle skriven i
Rust},label=selection-sort, label={lst:gsr},firstline=179, lastline=214]{../simulation_rust/src/main.rs}
%\lstinputlisting[language=Rust, firstline=179, lastline=214]{../simulation_rust/src/main.rs}

\section{Kod för Pile Shuffle}
\label{app:pile}
\lstinputlisting[language=Rust, firstline=29, lastline=55]{../simulation_rust/src/main.rs}

\section{Kod för Wheel Fisher-Yates Shuffle}
\label{app:wheel}
\lstinputlisting[language=Rust, firstline=147, lastline=167]{../simulation_rust/src/main.rs}

\section{Resultat av STDMean test}
\label{app:stdmean}
\input{resultat_std_mean}

% \section{Template att bifoga ett inline kod}
% \label{sec:source_code}
% \begin{lstlisting}[language=Python, caption=Python example]
% # Your source code here
% print("Hello, World!")
% \end{lstlisting}

% \section{Template att bigoga källkod ifrån git repo}
% \label{app:source_code2}
%\lstinputlisting[language=Rust, caption={algorithm 1 implemention},label=selection-sort, label={lst:algo_1},firstline=24, lastline=50]{../simulation_rust/src/main.rs}


\end{document}

